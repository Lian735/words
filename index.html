<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Auto</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="world"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;

        // Create engine
        const engine = Engine.create();
        const world = engine.world;

        // Create renderer
        const render = Render.create({
            element: document.body,
            canvas: document.getElementById('world'),
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#87CEEB'
            }
        });

        Render.run(render);

        // Create runner
        const runner = Runner.create();
        Runner.run(runner, engine);

        // Create terrain
        const terrain = [];
        const terrainWidth = 2000;
        const terrainHeight = window.innerHeight - 100;
        const segments = 50;
        const segmentWidth = terrainWidth / segments;
        let lastHeight = terrainHeight / 2;

        for (let i = 0; i <= segments; i++) {
            const x = i * segmentWidth;
            const y = lastHeight + (Math.random() * 100 - 50);
            terrain.push({ x, y });
            lastHeight = y;
        }

        const terrainVertices = terrain.map(point => ({ x: point.x, y: point.y })).concat([
            { x: terrainWidth, y: window.innerHeight },
            { x: 0, y: window.innerHeight }
        ]);

        const terrainBody = Bodies.fromVertices(terrainWidth / 2, terrainHeight / 2, [terrainVertices], { isStatic: true, render: { fillStyle: '#8B4513' } });
        Composite.add(world, terrainBody);

        // Create car
        const carWidth = 80;
        const carHeight = 40;
        const wheelSize = 20;

        const carBody = Bodies.rectangle(100, terrainHeight / 2 - carHeight, carWidth, carHeight, {
            render: {
                fillStyle: '#FF0000'
            }
        });

        const wheelA = Bodies.circle(80, terrainHeight / 2, wheelSize, {
            render: {
                fillStyle: '#000000'
            }
        });

        const wheelB = Bodies.circle(120, terrainHeight / 2, wheelSize, {
            render: {
                fillStyle: '#000000'
            }
        });

        const axleA = Matter.Constraint.create({
            bodyA: carBody,
            pointA: { x: -carWidth / 2 + wheelSize, y: carHeight / 2 },
            bodyB: wheelA,
            stiffness: 0.2,
            length: 0
        });

        const axleB = Matter.Constraint.create({
            bodyA: carBody,
            pointA: { x: carWidth / 2 - wheelSize, y: carHeight / 2 },
            bodyB: wheelB,
            stiffness: 0.2,
            length: 0
        });

        Composite.add(world, [carBody, wheelA, wheelB, axleA, axleB]);

        // Follow the car
        Events.on(engine, 'beforeTick', () => {
            const offsetX = -carBody.position.x + render.options.width / 4;
            const offsetY = -carBody.position.y + render.options.height / 2;
            Render.lookAt(render, {
                min: { x: carBody.position.x - render.options.width / 2, y: carBody.position.y - render.options.height / 2 },
                max: { x: carBody.position.x + render.options.width / 2, y: carBody.position.y + render.options.height / 2 }
            });
        });

        // Move car
        const forceMagnitude = 0.01;
        const applyForce = () => {
            Body.applyForce(carBody, carBody.position, { x: forceMagnitude, y: 0 });
        };

        setInterval(applyForce, 50);

        // Resize canvas
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;
            Render.lookAt(render, {
                min: { x: carBody.position.x - render.options.width / 2, y: carBody.position.y - render.options.height / 2 },
                max: { x: carBody.position.x + render.options.width / 2, y: carBody.position.y + render.options.height / 2 }
            });
        });
    </script>
</body>
</html>
